## Java基础

### 1.15

- [ ] ##### **什么是java虚拟机？为什么java被称作“平台无关的编程语言”？**

java虚拟机是一个可以执行java字节码的虚拟机进程。java源文件被编译成能被java虚拟机执行的字节码文件。

java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或重新编译。java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

- [ ] ##### **JDK和JRE的区别是什么？**

JRE是java运行环境，它包括java虚拟机、java核心类库和支持文件。它不包含开发工具（编译器、调试器、其他工具）。

Java开发工具包（JDK）是完整的Java软件开发包，包含了JRE，编译器和其他工具（如JavaDoc，Java调试器），可以让开发者开发、编译。执行Java应用程序。

- [ ] ##### “static”关键字是什么意思？Java中是否可以覆盖（override）一个private或者static的方法？

“static”关键字表明一个成员变量或者成员方法可以在没有所属类的实例变量的情况下被访问。

java中static方法不能被覆盖，因为方法是基于运行时的动态绑定，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

除此之外，Java也不能覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法，当然也不可覆盖。

**绑定**：一个方法与类/对象联系起来

**静态绑定**：如果是private、static、final方法，编译器可以准确的指导应该调用哪些方法，因为子类不能重写这些方法；这样的调用方式叫做静态绑定（static binding）

**动态绑定**：调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。

虚拟机先在该队形中寻找是否有该方法，如果有直接调用，如果没有则在超类中寻找。但每次调用方法都要进行搜索，时间开销会相当大。因此虚拟机为每个类预先创建了一个方法表，其中类处理所有方法的签名和实际调用的方法。

**方法重载**：同类中，方法名相同，方法参数列表不同；

**方法覆盖**：重写方法体，但具有相同的名称、返回类型、参数列表。

- [ ] ##### 是否可以在static环境中访问的非static变量

不可以。static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果代码尝试不用实例化来访问非static变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟热呢实例关联上。

（因为静态的成员属于类，随着类的加载而加载到静态方法去的内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态成员）

- [ ] ##### java支持的数据类型有哪些？什么是自动拆装箱？

有八种基本的数据类型：比 byte/8,short/16,int/32,long/64,float/32,double/64,boolean/~,char/16;

自动拆装箱是Java编译器在基本数据类型和对用的对象包装类型之间做的一个转化。int->Integer double->Double ，反之就是自动拆箱。

- [ ] ##### Java中方法覆盖（overriding）和方法重载（overload）是什么意思？

java中的方法重载发生在同一个类中两个或者多个方法的方法名相同但是参数不用的情况。与此相对，方法覆盖是说子类重新定义父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型，覆盖着不会限制它所覆盖方法的访问。

重载发生在编译时，编译器可以根据参数类型来选择使用哪个方法；

重写发生在运行时，由JVM在代码运行时做出决定；

**重写原则**：不可比原方法访问性差，不能比原方法抛出更多异常；不能重写final，static，private方法

- [ ] ##### java中什么是构造方法？什么是构造方法重载，什么是复制构造方法？

当对象被创建时，构造方法会被调用。每一类都有构造方法。在程序员没有给类提供构造方法的情况下，java编译器会为这个类创建一个默认的构造方法。

Java中的构造方法重载和方法重载很类似，它可以为一个类创建多个构造方法。每个构造方法必须有它位图的参数列表。

复制构造方法就是将本类的对象作作为参数的构造函数，目的是用一个已经实例化的对象来初始化另一个对象，简单来说就是拷贝一个对象。（通过对象中的clone()进一步实现）

~~java不支持像C++中那样复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的构造方法。（在C++中即拷贝构造函数）~~

- [ ] ##### java支持多继承吗？

java类中不支持多继承，只支持单继承（一个类只有一个父亲）。但在java中的接口提供多继承，即一个接口可以有多个父接口（接口的接口的作用是用来扩展对象的功能，一个子接口集成多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了响应的功能。

- [ ] ##### 接口和抽象类的区别是什么？

***从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范***

- [ ] ##### 什么是值传递和引用传递？

值传递是对基本型变量而言，传递的是该变量的一个副本，改变副本不影响原变量。

引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本而不是原对象本身。

一般认为，java内的基础类新数据传递都是值传递，Java中实例对象的传递是引用传递。

### 1.16

- [ ] ##### 进程和线程的区别是什么？

进程是运行中的程序，线程是进程的内部一个执行序列；

进程是资源分配的单元，线程是执行的单元；

进程前切换代价大，线程切换代价小；

进程拥有的资源多，线程拥有的资源少；

多个线程共享进程内的资源；

- [ ] ##### 创建线程有几种不同的方式？你喜欢哪一种？为什么？

*一般使用第二种*

①继承Thread【/θred/】类（真正意义上的线程类），是Runnable接口的实现；

②实现Runnable接口，并重写里面的run方法。（**优点**：避免了单继承带来的局限性；适合于资源的共享；）

③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现；

④实现callable接口，重写call方法，有返回值；



**Thread的常用方法**

start() 启动线程并执行相应的run()方法

run() 子进程要执行的代码放进run()方法中

currentThread() 静态的，调取当前线程

getName() 获取此线程的名字

setName() 设置此线程的名字

yield() 调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）

join() 在A线程中调用B线程的join方法，表示：当执行到此方法时，A线程停止执行，直到B进程至此那个完毕，A线程再接着join之后的代码执行；

isAlive() 判断当前线程是否存活

sleep(long I) 显式地让当前线程睡眠I毫秒（只能捕捉异常，因为父类run方法没有抛异常）

**线程通讯**

wait()： 当一个线程调用object.wait()，他就会进入object对象的等待队列，这个等待队列中可能有多个线程，因为系统运行多个线程同时等待同一对象；

notify()： 当object对象调用object.notify()方法，就会从这个等待队列，随机选择一个线程将其唤醒，这里的选择是不公平的，完全随机的

notifyAll()：它与notify()方法的功能基本一致，不同的是它在唤醒这个等待队列中的所有等待线程而不是随机选择一个

**线程优先级**

getPriority(): 返回线程优先级

setPriority（int newPriority）：改变线程的优先级；

- [ ] ##### 概括的解释线程的几种可用态

1. 新建( new )：新创建了一个线程对象。

2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。

3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。

4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：

   (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。

   (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。

   (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。      当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。

5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。

![img](http://uploadfiles.nowcoder.com/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD)

- [ ] ##### 为什么使用同步？

java允许多线程并发控制，当多个线程同时操作有个可共享的资源变量时（增删改查），将会导致数据的不准确，相互之间产生冲突。因此加入同步锁，以避免该县城没有结束前，调用其他线程，从而保证了变量的唯一性，准确性。

- [ ] ##### 同步方法和同步代码块的区别是什么？

同步方法默认使用this或者当前前类class对象作为锁；

同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步发生同步问题的部分代码而不是整个方法；

同步方法使用关键字synchronized修饰方法（['sɪŋkrənaɪzd]）修饰方法，而同步代码块主要是修饰需要进行同步的代码，用synchronized(object){代码内容}进行修饰；

- [ ] ##### 在监视器（Monitor）内部，是如何做到线程同步的？程序应该做哪种级别的同步？

在Java虚拟机中，每个对象（object和class）通过某种逻辑关系关联监视器，每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每一个对象都关联着一把锁；

一旦代码被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码；

另外Java还提供了显式监视器（Lock）和隐式监视器（synchronized）两种锁方案。

- [ ] ##### 什么是死锁（deadlock）

**死锁**：是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，他们都将无法推进下去

①**互斥条件**：一个资源每次只能被一个进程使用

②**请求与保持条件**：一个进程因请求资源而组设，对已获得的资源保持不放；

③**不剥夺条件**：进程已获得的资源，在未使用完之前，不能强行剥夺；

④**循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

~~不可抢占，互斥，占有且等待，循环等待~~

- [ ] ##### 如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

##### Java集合类框架的基本接口有哪些？

![img](https://uploadfiles.nowcoder.com/images/20170725/344533_1500957622324_CA997C62E8C3C22308FAC7A2003F2F2A)

总共有两大接口：collection和Map，一个元素集合，衣蛾键值对集合；其中List和Set节后集成了Collection接口，一个是有序元素集合，一个无需元素集合；而ArrayList和LinkedList实现了List接口，HashSet实现了Set接口；HashMap和HashTable实现了Map接口，HashTable是线程安全的，但是HashMap性能更好；

### 1.17

- [ ] ##### 为什么集合类没有实现cloneable和Serializable接口？

克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。

**序列化**：把对象转换成字节序列的过程称作为对象的序列化；

**反序列化**：把字节序列恢复为对象的过程称为对象的反序列化；

**具体实现**:

flypig对象

```java
 	private static String AGE = "269";
    private String name;
    private String color;
    transient private String car;
```

序列化

```java
private static void serializeFlyPig() throws IOException {
        FlyPig flyPig = new FlyPig();
        flyPig.setColor("black");
        flyPig.setName("naruto");
        flyPig.setCar("0000");
        // ObjectOutputStream 对象输出流，将 flyPig 对象存储到E盘的 flyPig.txt 文件中，完成对 flyPig 对象的序列化操作
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("d:/flyPig.txt")));
        oos.writeObject(flyPig);
        System.out.println("FlyPig 对象序列化成功！");
        oos.close();
    }
```

反序列化

```java
private static FlyPig deserializeFlyPig() throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("d:/flyPig.txt")));
        FlyPig person = (FlyPig) ois.readObject();
        System.out.println("FlyPig 对象反序列化成功！");
        return person;
```

ObjectOutputStream代表对象输出流：
它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。
ObjectInputStream代表对象输入流：
它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。

transient 修饰的属性，是不会被序列化的。

static修饰的属性，也不会被序列化

为了不必要的报错麻烦： 序列化时最好是定义序列化版本id 即 public static final Long seriaVersionUID = 1L (默认) 或者 xxxxx L（自定义64位都行）

**序列化的作用**：方便传输，速度快，很安全，常用于不同进程之间的对象传输；方便存储，可存储文件或者数据库；

##### 什么是迭代器（Iterator）？

~~Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除低层级和的元素，但不可以直接调用集合的remove（Object obj）删除，可以通过迭代器的remove()方法删除；~~

迭代器是一种设计模式，它是一个对象，它可以便利并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小；

Java中的iterator功能比较简单，只能单向移动；

①使用方法iterator()要求容器返回一个Iterator。第一次调用iterator的next()方法时，它返回序列的第一个元素；

②使用next()获得序列的下一个元素；

③使用hashNext()检查序列中是否还有元素；

④使用remove()将迭代器新返回的元素删除；

为List设计的ListIterator具有更多的功能，他可以从两个方向遍历List，也可以从List中插入和删除元素。

```java

	//Iterable接口
      Iteratoriterator();
	//Iterator接口
      boolean hasNext();
      E next();
      void remove();
```

### 1.18

##### Iterator和ListIterator的区别是什么？

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List；

Iterator对集合只能是前项遍历，ListIterator亦可以前项也可以后项；

ListIterator实现了对Iterator接口，并包含其他功能，比如：增加元素，替换元素，获取前一个元素和后一个元素的索引，等等。

![img](https://uploadfiles.nowcoder.com/images/20160808/733131_1470636931013_13A06D025548C29F6AAFF3CB2EE0CCCF)

![img](https://uploadfiles.nowcoder.com/images/20160808/733131_1470636870149_A99B8AC1B2797AE567C4F897B8902D94)

- [ ] ##### 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

**快速失败**：在使用迭代器对集合对象进行遍历的时候，如果A线程正在对集合进行遍历，此时B线程对集合进行修改（增加、删除、修改），或者A线程在遍历过程中对集合进行修改，都会导致A线程抛出CurrentModificationException异常

**原因是**在迭代器在遍历时直接访问集合中的内容，并在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值；每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历；

（注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。）

**安全失败**：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝集合上进行遍历；

**缺点**：在遍历期间的修改迭代器不知道；

在java.util.concurrent包下的全是安全失败的。

- [ ] ##### Java中的HashMap的工作原理是什么？

hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null；

hashmap的内部实现，hashmap是使用数组+链表+红黑树的形式实现的，其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。

然后再说一下hashmap的方法实现
 put方法，put方法的第一步，就是计算出要put元素在hash桶数组中的索引位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，**取模运算就是用第二步得到的值和hash桶数组长度-1的值取与**。这样得到的结果和传统取模运算结果一致，而且效率比取模运算高

jdk1.8中put方法的具体步骤，先判断hashmap是否为空，为空的话扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束
 get方法就是计算出要获取元素的hash值，去对应位置取即可。
 扩容机制，hashmap的扩容中主要进行两部，第一步把数组长度变为原来的两倍，第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。
 **hashmap大小为什么是2的幂次方**
 在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方
 如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。

- [ ] ##### hashCode()和equals()方法的重要性在什么地方？

Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

（hashCode()用来定位要存放的位置，equal()用来判断是否相等；**而涉及到HashMap的时候，重写了equals()，就需要重写hashCode()**）

- [ ] ##### HashMap与Hashtable的区别

- Hashtable 使用 synchronized 来进行同步，HashMap不同步；（因此HashMap更适合于单线程，HashTable适合于多线程）

- HashMap 可以插入键为 null 的 Entry。

- HashMap 的迭代器是 fail-fast 迭代器。

- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

- [ ] ##### 数组(Array)和列表(ArrayList)有什么区别？什么时候使用Array而不是ArrayList？

- Array可以包含基本类型和对象类型，而ArrayList只能包含对象类型。

- Array大小是固定的，ArrayList的大小是动态变化的。

- ArrayList是Array的加强版，它提供了更多的方法和特性（如addAll(),removeAll(),iterator()）等等；

- [ ] ##### ArrayList和LinkedList有什么区别？

ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删

### 1.19

- [ ] ##### 如何获得掩码？

① 使用Integer.highestOneBit(int num)方法，如101调用这个方法得到4（100），然后左移一位减1得到掩码（速度最慢）

```java
	int mask = (Integer.highestOneBit(num)<<1)-1;
```

```java
	public static int highestOneBit(int i) {
        i |= (i >>  1);
        i |= (i >>  2);
        i |= (i >>  4);
        i |= (i >>  8);
        i |= (i >> 16);
        return i - (i >>> 1);
    }
	//第一步的作用是右移移位，并与原数据按位取或。
```

②把值为1的mask左移30位，使1放在最高位剩下位为0，然后和num做&运算，直到不得0为止mask要一直右移，此时mask的停留在num的最高位1处，然后左移一位减1得到掩码

```java
	int mask = 1 << 30;
	while ((num & mask) == 0) mask >>= 1;
	mask = (mask << 1) - 1;
```

③ 用num与num左移的数字做或运算赋给num（速度最快），例如对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：
mask |= mask >> 1 11000000
mask |= mask >> 2 11110000
mask |= mask >> 4 11111111

```java
	int mask = num;
	mask |= mask >> 1;
	mask |= mask >> 2;
	mask |= mask >> 4;
	mask |= mask >> 8;
	mask |= mask >> 16;
```

- [ ] ##### 红黑树

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**

从性质5又可以推出：

- 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点

**黑色完美平衡**：左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。

- **左旋**：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。
- **右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。
- **变色**：结点的颜色由红变黑或由黑变红。

**红黑树的查找**

与二叉平衡树查找相同，但红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)

**红黑树的插入**

插入位置查找